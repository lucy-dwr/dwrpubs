#' Author normalization helpers
#'
#' Utility functions for working with Crossref and OpenAlex author data.
#'
#' @keywords internal
#' @name author_normalization_helpers
#' @noRd
NULL

#' Extract author display names from an OpenAlex authorships entry
#'
#' @param authorships Tibble/list from the `authorships` column of an OpenAlex
#'   work.
#' @param name_columns Candidate column names storing author display names.
#'
#' @return Character vector of unique, non-empty author names (possibly length
#'   zero).
#'
#' @export
extract_openalex_author_names <- function(
  authorships,
  name_columns = c("display_name", "author.display_name")
) {
  if (is.null(authorships) || !NROW(authorships)) {
    return(character())
  }

  if (!is.data.frame(authorships)) {
    authorships <- tibble::as_tibble(authorships)
  }

  cols <- intersect(name_columns, names(authorships))

  if (!length(cols)) {
    return(character())
  }

  names <- authorships[[cols[[1]]]]

  if (is.list(names)) {
    names <- unlist(names, use.names = FALSE)
  }

  names <- trimws(as.character(names))
  names <- names[nzchar(names) & !is.na(names)]

  unique(names)
}

#' Build canonical author-affiliation pairs from OpenAlex authorships
#'
#' Normalizes a single OpenAlex `authorships` entry into a tidy tibble pairing
#' each author with their canonical affiliation(s) using a previously generated
#' lookup table.
#'
#' @param authorships Tibble/list returned in the `authorships` column of an
#'   OpenAlex work.
#' @param lookup Tibble with `original` and `canonical` columns generated by
#'   `canonicalize_affiliation_values()`.
#' @param name_columns Candidate column names containing author display names.
#' @param affiliation_fields Candidate fields to inspect when gathering raw
#'   affiliation strings for a single authorship row.
#'
#' @return Tibble with `author` and `canonical_affiliation` columns. The tibble
#'   may have zero rows when no author or affiliation data is available.
#'
#' @keywords internal
#' @noRd
build_openalex_author_affiliations <- function(
  authorships,
  lookup,
  name_columns = c("display_name", "author.display_name"),
  affiliation_fields = c("display_name", "name", "affiliation_raw", "raw_affiliation")
) {
  empty_result <- function() {
    tibble::tibble(
      author = character(),
      canonical_affiliation = character()
    )
  }

  if (is.null(authorships) || !NROW(authorships) || !nrow(lookup)) {
    return(empty_result())
  }

  if (!is.data.frame(authorships)) {
    authorships <- tibble::as_tibble(authorships)
  }

  rows <- seq_len(nrow(authorships))

  results <- purrr::map_dfr(rows, function(i) {
    row <- authorships[i, , drop = FALSE]

    author_name <- extract_openalex_author_names(
      row,
      name_columns = name_columns
    )
    author_name <- purrr::pluck(author_name, 1, .default = NA_character_)

    raw_affiliations <- collect_openalex_affiliations(
      row,
      fields = affiliation_fields
    )
    canonical <- map_canonical_affiliations(raw_affiliations, lookup)

    if (!length(canonical)) {
      canonical <- NA_character_
    }

    if (is.na(author_name) && all(is.na(canonical))) {
      return(empty_result())
    }

    tibble::tibble(
      author = rep.int(author_name, length(canonical)),
      canonical_affiliation = canonical
    )
  })

  if (!nrow(results)) {
    return(empty_result())
  }

  results
}

#' Build author-affiliation pairs from Crossref author data
#'
#' Normalizes a Crossref `author` entry into a tidy tibble pairing each author
#' with the affiliation string supplied by Crossref.
#'
#' @param authors Crossref author data; typically a tibble or list structure as
#'   produced by `cr_fetch_works()` and normalized with `format_crossref_authors()`.
#'
#' @return Tibble with columns `author` and `affiliation`. Returns zero rows
#'   when no author data is available.
#'
#' @keywords internal
build_crossref_author_affiliations <- function(authors) {
  empty_result <- function() {
    tibble::tibble(
      author = character(),
      affiliation = character()
    )
  }

  if (is.null(authors) || !length(authors)) {
    return(empty_result())
  }

  normalized <- normalize_crossref_authors(authors)
  if (!nrow(normalized)) {
    return(empty_result())
  }

  names <- trimws(as.character(normalized$author_name))
  names[!nzchar(names)] <- NA_character_

  affiliations <- trimws(as.character(normalized$author_affiliation))
  affiliations[!nzchar(affiliations)] <- NA_character_

  result <- tibble::tibble(
    author = names,
    affiliation = affiliations
  )

  mask <- is.na(result$author) & is.na(result$affiliation)
  if (any(mask)) {
    result <- result[!mask, , drop = FALSE]
  }

  result
}

extract_crossref_affiliations <- function(author_affiliations) {
  if (is.null(author_affiliations) || !is.data.frame(author_affiliations) || !nrow(author_affiliations)) {
    return(character())
  }

  if (!"affiliation" %in% names(author_affiliations)) {
    return(character())
  }

  values <- trimws(as.character(author_affiliations$affiliation))
  values <- values[!is.na(values) & nzchar(values)]
  unique(values)
}

canonicalize_crossref_author_affiliations <- function(author_affiliations, lookup) {
  empty_result <- function() {
    tibble::tibble(
      author = character(),
      canonical_affiliation = character()
    )
  }

  if (is.null(author_affiliations) || !is.data.frame(author_affiliations) || !nrow(author_affiliations)) {
    return(empty_result())
  }

  authors <- as.character(author_affiliations$author)
  raw_affiliations <- if ("affiliation" %in% names(author_affiliations)) {
    author_affiliations$affiliation
  } else {
    rep(NA_character_, length(authors))
  }

  raw_affiliations <- trimws(as.character(raw_affiliations))
  raw_affiliations[!nzchar(raw_affiliations)] <- NA_character_

  canonical <- rep(NA_character_, length(raw_affiliations))
  if (!is.null(lookup) && nrow(lookup)) {
    matches <- lookup$canonical[match(raw_affiliations, lookup$original)]
    canonical <- ifelse(is.na(matches), NA_character_, matches)
  }

  result <- tibble::tibble(
    author = authors,
    canonical_affiliation = canonical
  )

  result$canonical_affiliation <- normalize_canonical_output(result$canonical_affiliation)

  mask <- is.na(result$author) & is.na(result$canonical_affiliation)
  if (any(mask)) {
    result <- result[!mask, , drop = FALSE]
  }

  result
}

#' Normalize Crossref author structures into nested tibbles
#'
#' Converts the heterogeneous author entries returned by Crossref into a tidy
#' two-column tibble (`author_name`, `author_affiliation`) for each work.
#'
#' @param authors List-column or vector where each element represents the author
#'   data for a Crossref work (as returned in `cr_fetch_works()`).
#'
#' @return A list of nested tibbles matching the length of `authors`.
#'
#' @export
format_crossref_authors <- function(authors) {
  purrr::map(authors, tidy_crossref_author_entry)
}

#' Normalize Crossref authors into a standard tibble
#'
#' Produces a tibble with `author_name` and `author_affiliation` columns,
#' regardless of whether the input is already normalized or still in the raw
#' Crossref structure.
#'
#' @inheritParams format_crossref_authors
#'
#' @return Tibble with one row per author.
#'
#' @export
normalize_crossref_authors <- function(authors) {
  if (is.null(authors) || !length(authors)) {
    return(tibble::tibble(
      author_name = character(),
      author_affiliation = character()
    ))
  }

  if (is.data.frame(authors) && "author_affiliation" %in% names(authors)) {
    affil <- authors$author_affiliation
    n <- nrow(authors)
    names <- if ("author_name" %in% names(authors)) authors$author_name else rep(NA_character_, n)

    return(tibble::tibble(
      author_name = names,
      author_affiliation = affil
    ))
  }

  tidy_crossref_author_entry(authors)
}

tidy_crossref_author_entry <- function(entry) {
  if (is.null(entry) || !length(entry)) {
    return(tibble::tibble(
      author_name = character(),
      author_affiliation = character()
    ))
  }

  if (!is.data.frame(entry)) {
    entry <- tibble::as_tibble(entry)
  }

  rows <- seq_len(nrow(entry))

  purrr::map_dfr(rows, function(i) {
    row <- entry[i, , drop = FALSE]

    name <- extract_crossref_author_name(row)
    affiliation_data <- if ("affiliation" %in% names(row)) row$affiliation[[1]] else NULL
    scalar_affils <- collect_scalar_affiliations(row)
    affiliation <- extract_crossref_affiliation(affiliation_data, scalar_affils)

    tibble::tibble(
      author_name = name,
      author_affiliation = affiliation
    )
  })
}

collect_scalar_affiliations <- function(row) {
  cols <- names(row)
  matches <- grepl("^affiliation", cols, ignore.case = TRUE)

  values <- unlist(row[cols[matches]], use.names = FALSE)
  values <- trimws(as.character(values))
  values <- values[nzchar(values)]

  if (!length(values)) {
    return(character())
  }

  values
}

extract_crossref_author_name <- function(row) {
  pick_value <- function(value) {
    if (is.null(value) || !length(value)) {
      return(NA_character_)
    }

    if (is.list(value)) {
      value <- unlist(value, use.names = FALSE)
    }

    value <- trimws(as.character(value))
    value <- value[nzchar(value)]

    if (!length(value)) {
      return(NA_character_)
    }

    value[[1]]
  }

  get_col <- function(x, col) {
    if (col %in% names(x)) x[[col]] else NULL
  }

  name <- pick_value(get_col(row, "name"))

  if (is.na(name)) {
    name <- pick_value(get_col(row, "literal"))
  }

  if (is.na(name)) {
    given <- pick_value(get_col(row, "given"))
    family <- pick_value(get_col(row, "family"))
    parts <- c(given, family)
    parts <- parts[!is.na(parts)]

    if (length(parts)) {
      name <- trimws(paste(parts, collapse = " "))
    }
  }

  if (is.na(name) || !nzchar(name)) {
    return(NA_character_)
  }

  name
}

#' Extract author display names from Crossref author entries
#'
#' Normalizes a Crossref author entry and returns the unique, non-empty author
#' names. Useful for aligning Crossref outputs with OpenAlex metadata, which
#' stores authors as character vectors.
#'
#' @param authors Crossref `author` entry for a single work (raw or normalized).
#'
#' @return Character vector of author names (possibly length zero).
#'
#' @export
extract_crossref_author_names <- function(authors) {
  normalized <- normalize_crossref_authors(authors)

  if (!nrow(normalized) || !"author_name" %in% names(normalized)) {
    return(character())
  }

  names <- normalized$author_name
  names <- trimws(as.character(names))
  names <- names[!is.na(names) & nzchar(names)]

  unique(names)
}

extract_crossref_affiliation <- function(affiliation, extra = character()) {
  flatten <- function(x) {
    if (is.null(x) || !length(x)) {
      return(character())
    }

    if (is.data.frame(x)) {
      unlist(x, use.names = FALSE)
    } else if (is.list(x)) {
      unlist(x, recursive = TRUE, use.names = FALSE)
    } else {
      x
    }
  }

  values <- c(flatten(affiliation), extra)
  values <- trimws(as.character(values))
  values <- values[nzchar(values)]

  if (!length(values)) {
    return(NA_character_)
  }

  paste(unique(values)[1], collapse = "")
}
